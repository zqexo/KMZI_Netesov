# Алгоритм Евклида для нахождения наибольшего общего делителя (НОД)
print("Алгоритм Евклида")


def euclidean_algorithm(a, b):
    # Цикл продолжается до тех пор, пока b не станет равно 0
    while b != 0:
        # Остаток от деления a на b присваивается переменной r
        r = a % b
        # Значение b присваивается a
        a = b
        # Значение остатка r присваивается b
        b = r
    # Возвращаем a, которое теперь содержит НОД
    return a


# Пример использования алгоритма Евклида
a = 28
b = 8
gcd_result = euclidean_algorithm(a, b)
print(f"НОД({a}, {b}) = {gcd_result}")

# Расширенный алгоритм Евклида
print("\nРасширенный алгоритм Евклида")


def extended_euclidean_algorithm(a, b):
    # Инициализируем три строки: U и V, T для временного хранения результатов
    U = (a, 1, 0)
    V = (b, 0, 1)

    # Цикл продолжается до тех пор, пока первый элемент строки V не станет равным 0
    while V[0] != 0:
        # Вычисляем целую часть от деления u1 на v1
        q = U[0] // V[0]

        # Вычисляем новую строку T с использованием предыдущих значений U и V
        T = (U[0] % V[0], U[1] - q * V[1], U[2] - q * V[2])

        # Перемещаем значения: U присваиваем значения V, а V присваиваем значения T
        U = V
        V = T

    # Возвращаем U, где U[0] - это НОД, а U[1] и U[2] - коэффициенты x и y
    return U


# Пример использования расширенного алгоритма Евклида
a = 28
b = 19
gcd_result, x, y = extended_euclidean_algorithm(a, b)
print(f"НОД({a}, {b}) = {gcd_result}, x = {x}, y = {y}")
print(f"Проверка: {a} * ({x}) + {b} * ({y}) = {a * x + b * y}")

# Функция для нахождения обратного числа по модулю m
print("\nФункция нахождения обратного числа по модулю")


def modular_inverse(c, m):
    # Используем расширенный алгоритм Евклида для нахождения НОД и коэффициентов
    gcd_result, x, y = extended_euclidean_algorithm(m, c)

    # Если НОД равен 1, значит, обратный элемент существует
    if gcd_result == 1:
        # Возвращаем положительное значение инверсии по модулю m
        return y % m
    else:
        # Если НОД не равен 1, обратного элемента не существует
        return None


# Пример использования функции для нахождения обратного элемента по модулю
c = 3
m = 11
inverse = modular_inverse(c, m)
if inverse is not None:
    print(f"Обратное число {c} по модулю {m} = {inverse}")
else:
    print(f"Обратного числа для {c} по модулю {m} не существует")
