# Функция для простого возведения в степень по модулю
def power_mod_simple(a, b, m):
    result = 1  # Начальное значение результата
    for _ in range(b):  # Цикл от 0 до b (включительно)
        result = (result * a) % m  # Умножаем результат на a и берем модуль m
    return result  # Возвращаем итоговый результат


# Функция для быстрого возведения в степень по модулю
def power_mod_fast(a, b, m):
    result = 1  # Начальное значение результата
    a = a % m  # Берем модуль от основания для оптимизации
    while b > 0:  # Пока степень больше нуля
        if b % 2 == 1:  # Если степень нечетная
            result = (result * a) % m  # Умножаем на основание и берем модуль
        b //= 2  # Делим степень на 2 (целочисленное деление)
        a = (a * a) % m  # Возводим основание в квадрат и берем модуль
    return result  # Возвращаем итоговый результат


# Функция для тестирования методов возведения в степень по модулю
def test_power_mod():
    a = 3  # Основание
    b = 10  # Степень
    m = 7  # Модуль

    # Вычисляем результат с помощью простого метода
    result_simple = power_mod_simple(a, b, m)
    # Вычисляем результат с помощью быстрого метода
    result_fast = power_mod_fast(a, b, m)

    # Выводим результаты обоих методов
    print(f"Простой метод: {a}^{b} mod {m} = {result_simple}")
    print(f"Быстрый метод: {a}^{b} mod {m} = {result_fast}")


# Запускаем тест
test_power_mod()
